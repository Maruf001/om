
override_dir = '/nfs/cfel/cxi/data/2015/PETRA-2015-Bajt-Oct/raw/'
output_directory = None

# read the log files generated by Martin
import numpy as np
import sys, os
import glob
import h5py

def find_version(fnam) : 
    # read header
    with open(fnam) as f :
        #for line in f :
        while True :
            line = f.readline()
            line = line[1:].strip()
             
            # get the key value pair
            s           = line.split(':', 1)
            if len(s)  == 1 : s.append('')
            key, value  = convert(s[0]), convert(s[1]) 
            if key == 'Version' :
                return value

def read_mll_logfile(fnam, verbose = True):
    version = find_version(fnam)

    if version == 0.1 :
        print 'old version of log file. Rerouting...'
        Log = Log_file_v01(fnam)
    elif version == 0.2 :
        Log = Log_file_v02(fnam, verbose)
    elif version != self.version :
        print "unknown logfile version. Here's hoping..."
        Log = Log_file_v02(fnam, verbose)
    return Log
    

class Log_file_v02():
    """
    Pass a Martin log file as a python dictionary.
    
    Unless there is no slow axis.
    """
    version                   = 0.2
    header_tag                = '#'
    slow_axis_header          = 'Slow axis'
    fast_axis_header          = 'Fast axis'
    section_separator         = '----------------------'
    key_value_separator       = ':'
    unit_specifier            = ['[', ']']
    filename_placeholder      = 'Filename placeholder'
    filename_replacement_char = '$'
    filename_step_pad         = 5       # =5 for e.g. MLL_100_00015.nxs
    index_name                = 'Step'
    fly_scan_onefile          = True
    
    def __init__(self, fnam, verbose = True):
        self.fnam  = fnam
        self.verbose = verbose
        self.log   = self.read_mll_log(fnam)
        # 
        # the total number of 'predicted' frames for the scan
        # this will not be the same as the number of recorded 
        # frames in the case where a scan is prematurly terminated
        self.max_steps = (self.slow_repeats + 1) * self.slow_steps * (self.fast_repeats + 1) * self.fast_steps
        
        # the number of rows in the log table
        self.logged_frames = self.len_data
        

    def read_mll_log(self, fnam = None):
        if fnam is None :
            fnam = self.fnam
        
        if self.verbose: print 'reading logfile:', fnam
        log = {}
        # read header
        with open(fnam) as f :
            #for line in f :
            while True :
                line = f.readline()
                
                # is this line a header line?
                if len(line) == 1 : continue
                if line[0] != self.header_tag : break
                line = line[1:].strip()
                #print 'line:', line
                 
                # get the key value pair
                s           = line.split(self.key_value_separator, 1)
                if len(s)  == 1 : s.append('')
                key, value  = convert(s[0]), convert(s[1])
                
                # if we find '?? axis' then get the axis attrs
                if key == self.slow_axis_header or key == self.fast_axis_header :
                    #print '\nThis line is the start of an axis section:'
                    axis     = self.get_axis_att(f, key, value, stop = self.section_separator)
                    log[key] = axis
                
                elif key != self.section_separator :
                    if type(value) is str and len(value) > 0 and value[0] == '(':
                        log[key]    = value
                    else :
                        name, unit = get_name_unit(key)
                        #print 'This line is a key value line, with key, name, unit, value', key,'|', name,'|', unit,'|', value
                        log[name]   = value * unit

            # now 'line' is the column header
            columns = line.split('\t')    
            
            data0 = [line.split() for line in f]

            # convert 'None' to np.nan
            data = []
            for line in data0:
                data.append([x.strip() if x != 'None' else np.nan for x in line])

            self.len_data = len(data)

            if data != [] :
                # get rid of the end of line thing (\n)
                #for d in data:
                #    d[-1] = d[-1].strip()

                # str --> float
                data = np.array(data, dtype=np.float)

                # add the positions to the log
                log_out = add_col_info(log, columns, data)
    
                # add the positions to the axis objects
                # this looks confusing but esentially we are doing:
                # log_out['XPZT'] --> log['Fast axis']['POSITION']
                for axis in [self.fast_axis_header, self.slow_axis_header]:
                    if log.has_key(axis) :
                        if log_out.has_key(log[axis]['name']):
                            log[axis].update(log_out[log[axis]['name']])
                            del log_out[log[axis]['name']]

                for key in log_out.keys():
                    log[key] = log_out[key]
        
        # generate filenames for each step or line
        #print '\n filenames:'

        slow = self.slow_axis_header
        slow_steps   = 1
        slow_repeats = 0
        if log.has_key(slow):
            slow_steps = log[slow]['Steps']
            if log[slow].has_key('Repeat'):
                slow_repeats = log[slow]['Repeat']

        fast = self.fast_axis_header
        fast_steps   = 1
        fast_repeats = 0
        if log.has_key(fast):
            fast_steps = log[fast]['Steps']
            if log[fast].has_key('Repeat'):
                fast_repeats = log[fast]['Repeat']

        self.slow_repeats = slow_repeats
        self.slow_steps   = slow_steps
        self.fast_repeats = fast_repeats
        self.fast_steps   = fast_steps
        step = 0
        fnams = []
        steps = []

        if self.fly_scan_onefile is True :
            for ii in range(slow_repeats + 1):
                if log.has_key(slow) and log[slow]['Scan type'] == 'Fly':
                    fnam = make_nxs_filename(log, step, include_dir = False)
                    fnams.append(fnam)
                    step_size = fast_steps * (fast_repeats + 1) + slow_steps
                    steps.append(range(step, step+step_size))
                    step += step_size
                else :
                    for i in range(slow_steps):
                        for jj in range(fast_repeats + 1):
                            if log[fast]['Scan type'] == 'Fly':
                                fnam = make_nxs_filename(log, step, include_dir = False)
                                fnams.append(fnam)
                                step_size = fast_steps 
                                steps.append(range(step, step+step_size))
                                step += step_size
                            else :
                                for j in range(fast_steps):
                                    fnam = make_nxs_filename(log, step, include_dir = False)
                                    fnams.append(fnam)
                                    steps.append(range(step, step+1))
                                    step += 1
        else :
            for ii in range(slow_repeats + 1):
                for i in range(slow_steps):
                    for jj in range(fast_repeats + 1):
                        for j in range(fast_steps):
                            fnam = make_nxs_filename(log, step, include_dir = False)
                            fnams.append(fnam)
                            steps.append(range(step, step+1))
                            step += 1
        
        log['Files']          = {}
        log['Files']['dir']   = log['Output directory']    
        log['Files']['fnams'] = fnams
        log['Files']['steps'] = steps
        return log
    
    def get_nxs_fnams(self, directory = None, dir_level = 0):
        """
        Look for the files (check which files are actually written) 
        and return the list (with the directory pre-appended).
        
        directory: overide the directory stored in the logfile 
                   in case the files have moved
        dir_level: apply the directory overide up to the n'th last 
                   directory.
        
                   e.g. 
                   get_nxs_fnams('/where/ever/', 2)
                   with the expected fnams :
                   /a/b/c/d/e/MLL_100_00000.nxs
                   /a/b/c/d/e/MLL_100_00001.nxs
                   ...
                    
                   will instead look for:
                   /where/ever/d/e/MLL_100_00000.nxs
                   /where/ever/d/e/MLL_100_00001.nxs
                   ...
        """
        fnams = []
        steps = []
        
        if directory is None :
            directory = self.log['Files']['dir']

        for step, fnam in zip(self.log['Files']['steps'], self.log['Files']['fnams']):
            fnam_abs = os.path.join(self.log['Files']['dir'], fnam)
            
            tails = []
            head  = fnam_abs
            for i in range(dir_level + 1):
                head, tail = os.path.split(os.path.abspath(head))
                tails.append(tail)
            
            fnam_abs = directory  
            for tail in tails[::-1] :
                fnam_abs = os.path.join(fnam_abs, tail)

            fnam_found = glob.glob(fnam_abs)
            if fnam_found != [] :
                #print 'found:', fnam_found
                fnams.append(fnam_abs)
                steps.append(step)
            else :
                #print 'did not find:', fnam_abs
                pass

        self.no_fnams_found = len(fnams)
        self.no_steps_found = len([item for sublist in steps for item in sublist])
        return steps, fnams

    def get_axis_att(self, file, key, value, stop = '----------------------'):
        """
        reads the file and gets the following attributes
        for 'axis':
        # Slow axis: axisX                <-- key : value
        # Current position [um]: 0.000000
        # Start position [um]: 0.000000
        # End position [um]: -4.620000
        # Step size [um]: 0.040000
        # Steps: 117
        # Random position [%]: 10.00
        """
        axis = {}
        axis['name'] = value
        while True :
            line     = file.readline()
            if line[0] == '#':
                s          = line[1:].split(':')
                if len(s)  == 1 : s.append('')
                key, value = convert(s[0]), convert(s[1])
                
                if key == stop:
                    #print 'Ending axis section.\n'
                    return axis
                else :
                    name, unit = get_name_unit(key)
                    #print 'This line is a key value line, with key, unit, value', key, unit, value
                    axis[name] = value * unit


class Log_file_v01(Log_file_v02):
    version                   = 0.1
    section_separator         = None
    
    def get_axis_att(self, file, key, value, stop = None):
        """
        reads the file and gets the following attributes
        for 'axis':
        # Slow axis: axisX                <-- key : value
        # Current position [um]: 0.000000
        # Start position [um]: 0.000000
        # End position [um]: -4.620000
        # Step size [um]: 0.040000
        # Steps: 117
        # Random position [%]: 10.00
        """
        attrs = ['Current position', 'Start position' , 'End position', 'Step size', 'Steps', 'Random position', 'Scan type']
        axis = {}
        axis['name'] = value
        axis['Scan type'] = 'Step'
        while True :
            cur_line = file.tell()
            line     = file.readline()
            if line[0] == '#':
                s          = line[1:].split(':')
                if len(s)  == 1 : s.append('')
                key, value = convert(s[0]), convert(s[1])
                
                name, unit = get_name_unit(key)
                if name not in attrs:
                    #print 'Ending axis section.\n'
                    file.seek(cur_line)
                    return axis
                else :
                    axis[name] = value * unit

def update_progress(progress, algorithm, i, fnam):
    barLength = 15 # Modify this to change the length of the progress bar
    status = ""
    if isinstance(progress, int):
        progress = float(progress)
    if not isinstance(progress, float):
        progress = 0
        status = "error: progress var must be float\r\n"
    if progress < 0:
        progress = 0
        status = "Halt...\r\n"
    if progress >= 1:
        progress = 1
        status = "Done...\r\n"
    block = int(round(barLength*progress))
    text = "\r{0}: [{1}] {2}% {3} {4} {5} {6}".format(algorithm, "#"*block + "-"*(barLength-block), int(progress*100), i, fnam, status, " " * 5) # this last bit clears the line
    sys.stdout.write(text)
    sys.stdout.flush()

class Data_iterator():
    def __init__(self, steps, fnams):
        self.steps = steps
        self.fnams = fnams
        my_len = len([item for sublist in steps for item in sublist])
        self.__len__ = lambda : my_len
        self.index = 0
        
        # need a look up table for step --> fnam
        # --------------------------------------
        # this looks like:
        # table = [[0, 0, 'MLL_100_00000.nxs'], [[1, 1, 'MLL_100_00000.nxs']
        #          ...
        #         [[1000, 0, 'MLL_100_01000.nxs'], [[1001, 1, 'MLL_100_01000.nxs']]
        self.table = []
        for i in range(len(steps)):
            frame_index = 0
            for s in steps[i]:
                self.table.append([s, frame_index, fnams[i]])
                frame_index += 1
        
        # load the first file to get shape and dtype info
        self.frames_buffer = None
        self.count_time    = None
        self.steps_success = None
        self.load_buffer(0)
        self.shape = (len(self.frames_buffer),) + self.frames_buffer[0].shape
        self.dtype = self.frames_buffer[0].dtype

    def __iter__(self):
        return self

    def load_buffer(self, index):
        self.fnam_buffer = self.table[index][2]
        #print '\nloading', self.fnam_buffer
        self.frames_buffer = []
        self.count_time    = None
        self.steps_success = []
        try :
            f = h5py.File(self.fnam_buffer, 'r')
            for i in range(f['/entry/instrument/detector/data'].shape[0]):
                try :
                    self.frames_buffer.append(f['/entry/instrument/detector/data'][i])
                    self.steps_success.append(self.table[index + i][0])
                except :
                    print 'Failed to read frame:', i
            self.count_time    = f['/entry/instrument/detector/count_time'].value.copy() * 1.0e-3
            #print 'loading', self.table[index][1], f['/entry/instrument/detector/data']
            f.close()
            frame = self.frames_buffer[self.table[index][1]]
            self.shape = (len(self.frames_buffer),) + self.frames_buffer[0].shape
        
        # if file reading failed then try the next index
        except :
            self.index+=1 
            self.load_buffer(self.index)

    def next(self):
        frame = {}
        index = self.index
        if index < len(self) :
            # if the frame is not already in the buffer read it
            if self.table[index][2] != self.fnam_buffer :
                self.load_buffer(index)
            
            frame['data']       = self.frames_buffer[self.table[index][1]]
            frame['count_time'] = self.count_time
            frame['step']       = self.steps_success[self.table[index][1]]           
            self.index += 1
            return frame 
        else :
            raise StopIteration()

        
def read_nxs_files(steps, fnams, no_data = False):
    """
    returns a flattend list of the steps and reads the frames
    if no_data is True then the actual reading of the data 
    is skipped and an iterator is returned instead.
    """
    steps_read = []
    steps_nested_read = []
    fnams_read = []
    datas      = []
    total_steps = len([item for sublist in steps for item in sublist])
    for step, fnam in zip(steps, fnams):
        try :
            f = h5py.File(fnam, 'r')
            if not no_data :
                data = f['/entry/instrument/detector/data'].value.copy()
            else :
                # read it to check for errors
                temp = f['/entry/instrument/detector/data'][0,0]
                del temp 
            f.close()
            
            fnams_read.append(fnam)
            steps_nested_read.append(step)
            for i in range(len(step)) :
                if not no_data :
                    datas.append(data[i])
                steps_read.append(step[i])
                  
                progress = float(len(steps_read)) / float(total_steps) 
                update_progress(progress, 'loading nxs files', len(steps_read), fnam)
    
        except Exception, e :
            print 'failed to read step:', step, str(e)
        
    if no_data is False :
        datas = np.array(datas)
    else :
        datas = Data_iterator(steps_nested_read, fnams_read)
    return steps_read, datas
    
def get_scanno_from_fnam(fnam):
    """:
    The logfiles should have names like:
    MLL_3.dat 
    I am going to call the "scan number" the first number
    before the "." and after the last "_"
    """
    # say fnam = 'MLL_3kjshfla_234234_5.dsaasd'
    
    scanno = fnam.split('.')[-2] 
    # now scanno = 'MLL_3kjshfla_234234_5'
    
    scanno = scanno.split('_')[-1]
    # now scanno = '5'
    
    scanno = int(scanno) 
    # now scanno = 5
    
    return scanno

def make_nxs_filename(log, step, include_dir = True):
    """
    $Beamtime ID$_$Scan number$_$Step$.nxs --> MLL_3_00011.nxs
    """
    if include_dir :
        fnam = log['Output directory'] 
    else :
        fnam = ''
    
    t = log['Filename placeholder'].split('$')
    
    count = 0
    for tt in t :
        # ignore '' 
        if tt == '' :
            continue
        # every second element is a separator
        # (if it is not the '.nxs' at the end)
        if (count % 2 == 1) and tt[0] != '.':
            fnam += tt

        elif tt == 'Step' :
            fnam += str(step).zfill(5)

        elif tt[0] == '.':
            fnam += tt

        else :
            fnam += str(log[tt])

        count += 1 
    return fnam

def getStatus(log):
    """
    Check how much of the run has completed
    """
    status = float(len(log['Timestamp'])) / float(log['Slow axis']['Steps'] * log['Fast axis']['Steps'])
    return status

def convert(a):
    try :
        b = int(a)
    except :
        try :
            b = float(a)
        except :
            b = a.strip()
    return b

units = {
        'deg': np.pi / 180.,
        '%': 1.0e-2, 
        'm':  1.0,
        'cm': 1.0e-2,
        'mm': 1.0e-3,
        'um': 1.0e-6,
        'nm': 1.0e-9,
        'pm': 1.0e-12,
        'fm': 1.0e-15,
        'UnixTime': 1.0, 
        'FormatedTime': 1,
        's':  1.0,
        'cs': 1.0e-2,
        'ms': 1.0e-3,
        'us': 1.0e-6,
        'ns': 1.0e-9,
        'ps': 1.0e-12,
        'fs': 1.0e-15,
        'POSITION': 1,
        'None': None,
        # this is an uncalibrated unit of distance for the interferometer
        'steps': 1, 
        }

def str_to_unit(unit):
    """
    convert the unit str into the multiplicative 
    factor required to make the number SI.
    so if unit = 'um' then return 1.0e-6
    Units:
    
    fractions
    ---------
    %  1.0e-2
    
    length
    ------
    m  1.0
    cm 1.0e-2
    mm 1.0e-3
    um 1.0e-6
    nm 1.0e-9
    pm 1.0e-12
    fm 1.0e-15
    
    time
    ------
    FormatedTime
    UnixTime 1.0
    s  1.0
    cs 1.0e-2
    ms 1.0e-3
    us 1.0e-6
    ns 1.0e-9
    ps 1.0e-12
    fs 1.0e-15

    None None
    """
    if unit not in units.keys():
        #print "I don't understand this unit. Must be one of: " + str(units.keys())
        raise ValueError("I don't understand this unit:",unit,". Must be one of: " + str(units.keys()))
    else :
        return units[unit]

def get_name_unit(key):
    """
    Converts strings like "Current position [um]"
    into name and unit.
    key    = "Current position [um]"
    return "Current position", 1.0e-6
    """
    # split key into e.g. ['Current position ', 'um]']
    s    = key.split('[')
    
    # call everything before the first '[' the name
    name = s[0].strip()

    # convert the 'um' string into a unit
    if len(s) == 1 :
        return name, 1
    
    elif s[-1][-1] == ']':
        unit = s[-1][:-1]
        unit = str_to_unit(unit)
        return name, unit


def get_col_name_attr_unit(col_header):
    """
    turn
    ['Timestamp [UnixTime]', 'axisX [POSITION][um]', 'axisY [POSITION][um]']
    into 
    ??
    """
    cols = []
    for c in col_header:
        col = {}
        s = c.split('[')
        # if the column header is just a name
        if len(s) == 1 :
            col['name'] = s[0].strip()
        
        # if the column header is name [unit] 
        elif len(s) == 2 :
            col['name'] = s[0].strip()
            col['unit'] = str_to_unit(s[1].split(']')[0])

        # if the column header is name [att][unit] 
        elif len(s) == 3 :
            col['name'] = s[0].strip()
            col['attr'] = s[1].split(']')[0]
            col['unit'] = str_to_unit(s[2].split(']')[0])

        cols.append(col)
    return cols

def add_col_info(log, columns, data):
    log_out = {}
    # get the column header stuff
    cols = get_col_name_attr_unit(columns)

    for i, c in enumerate(cols):
        if c['name'] not in log_out.keys():
            log_out[c['name']] = {}
        
        if c.has_key('attr') :
            if c.has_key('unit') :
                log_out[c['name']][c['attr']] = data[:, i] * c['unit']
            else :
                log_out[c['name']][c['attr']] = data[:, i] 
        
        elif c.has_key('unit') :
            log_out[c['name']] = data[:, i] * c['unit']
        
        else :
            log_out[c['name']] = data[:, i]
    
    return log_out

def parse_motor_log(fnam_motor_log, redo=False, verbose=False):
    """
    fnam_motor_log may be a list of motorlog file names in which case they are merged.
    I think all of the headers are just:
        # DETX [Position]: (DETX)(p11/motor/eh.2.04)(Position)
        # DETY [Position]: (DETY)(p11/motor/eh.2.05)(Position)
        # XMIC [POSITION]: (SmaractEncoded)(channel7)(POSITION)
        # YMIC [POSITION]: (Kohzu3)(channel2)(POSITION)
        # ZMIC [POSITION]: (SmaractEncoded)(channel8)(POSITION)
        # XSMP [POSITION]: (Kohzu1)(channel0)(POSITION)
        # YSMP [POSITION]: (Kohzu1)(channel1)(POSITION)
        # ZSMP [POSITION]: (Kohzu2)(channel0)(POSITION)
        # rSMP [POSITION]: (Kohzu2)(channel1)(POSITION)
        # pSMP [POSITION]: (Kohzu3)(channel0)(POSITION)
        # ySMP [POSITION]: (Kohzu3)(channel1)(POSITION)
        # XPZT [POSITION]: (Pi)(channel1)(POSITION)
        # YPZT [POSITION]: (Pi)(channel0)(POSITION)
        # XOSB [POSITION]: (SmaractEncoded)(channel4)(POSITION)
        # YOSB [POSITION]: (SmaractEncoded)(channel5)(POSITION)
        # ZOSB [POSITION]: (SmaractEncoded)(channel6)(POSITION)
        # XML2 [POSITION]: (SmarPod2)(channel0)(POSITION)
        # YML2 [POSITION]: (SmarPod2)(channel2)(POSITION)
        # ZML2 [POSITION]: (SmarPod2)(channel1)(POSITION)
        # rML2 [POSITION]: (SmarPod2)(channel4)(POSITION)
        # pML2 [POSITION]: (SmarPod2)(channel3)(POSITION)
        # yML2 [POSITION]: (SmarPod2)(channel5)(POSITION)
        # XML1 [POSITION]: (SmarPod1)(channel0)(POSITION)
        # YML1 [POSITION]: (SmarPod1)(channel2)(POSITION)
        # ZML1 [POSITION]: (SmarPod1)(channel1)(POSITION)
        # rML1 [POSITION]: (SmarPod1)(channel4)(POSITION)
        # pML1 [POSITION]: (SmarPod1)(channel3)(POSITION)
        # yML1 [POSITION]: (SmarPod1)(channel5)(POSITION)
        # XBLD [POSITION]: (SmaractEncoded)(channel2)(POSITION)
        # YBLD [POSITION]: (SmaractEncoded)(channel3)(POSITION)
        # rBLD [POSITION]: (SmaractNotEncoded)(channel0)(POSITION)
        # XAPT [POSITION]: (SmaractEncoded)(channel0)(POSITION)
        # YAPT [POSITION]: (SmaractEncoded)(channel1)(POSITION)
        Datetime [FormatedTime],Timestamp [UnixTime],DETX [Position][mm],DETY [Position][mm],XMIC [POSITION][um],YMIC [POSITION][um],ZMIC [POSITION][um],XSMP [POSITION][um],YSMP [POSITION][um],ZSMP [POSITION][um],rSMP [POSITION][deg],pSMP [POSITION][deg],ySMP [POSITION][deg],XPZT [POSITION][um],YPZT [POSITION][um],XOSB [POSITION][um],YOSB [POSITION][um],ZOSB [POSITION][um],XML2 [POSITION][um],YML2 [POSITION][um],ZML2 [POSITION][um],rML2 [POSITION][deg],pML2 [POSITION][deg],yML2 [POSITION][deg],XML1 [POSITION][um],YML1 [POSITION][um],ZML1 [POSITION][um],rML1 [POSITION][deg],pML1 [POSITION][deg],yML1 [POSITION][deg],XBLD [POSITION][um],YBLD [POSITION][um],rBLD [POSITION][deg],XAPT [POSITION][um],YAPT [POSITION][um]
    """
    print '\nReading motorlog file:'
    
    if redo is False :
        try :
            fnam = 'motorPositions_fixed.pickle'
            print '\nReading contents from', fnam
            import cPickle
            motor_pos = cPickle.load(open(fnam, 'rb'))
            return motor_pos
        except Exception, e:
            print str(e)
            pass
    
    if type(fnam_motor_log) is str :
        fnam_motor_logs = []
        fnam_motor_logs.append(fnam_motor_log)
    else :
        fnam_motor_logs = fnam_motor_log

    print fnam_motor_logs 
    motor_pos = {}
    for fnam in fnam_motor_logs :
        print fnam 
        with open(fnam, 'r') as f :
            for no, line in enumerate(f) :

                text = "\rparsing.. line : {0}".format(no) 
                sys.stdout.write(text)
                sys.stdout.flush()
                
                # if the first charactor in the line is a number then interpret this line as motor positions
                if line[0].isdigit() : 
                    pos = line.split(',')
                    for i, p in enumerate(pos) :
                        p = p.strip()
                        
                        if verbose : print i, p, col_names[i], att_names[i], convert(p), motor_pos[col_names[i]][att_names[i]]['unit']
                        
                        if p == '{}' or p == 'None' :
                            motor_pos[col_names[i]][att_names[i]]['value'].append(np.nan)
                        else :
                            motor_pos[col_names[i]][att_names[i]]['value'].append( convert(p) * motor_pos[col_names[i]][att_names[i]]['unit'] )
                    
                    #except Exception, e :
                    #    print '\n\nError parsing line', no, str(e)


                # if the first charactor in the line is '#' then treat it as a comment
                elif line[0] == '#' : 
                    pass

                if line.startswith('Datetime') :
                    col_names = []
                    att_names = []
                    header    = line #'Datetime [FormatedTime],Timestamp [UnixTime],DETX [Position][mm],DETY [Position][mm],XMIC [POSITION][um],YMIC [POSITION][um],ZMIC [POSITION][um],XSMP [POSITION][um],YSMP [POSITION][um],ZSMP [POSITION][um],rSMP [POSITION][deg],pSMP [POSITION][deg],ySMP [POSITION][deg],XPZT [POSITION][um],YPZT [POSITION][um],XOSB [POSITION][um],YOSB [POSITION][um],ZOSB [POSITION][um],XML2 [POSITION][um],YML2 [POSITION][um],ZML2 [POSITION][um],rML2 [POSITION][deg],pML2 [POSITION][deg],yML2 [POSITION][deg],XML1 [POSITION][um],YML1 [POSITION][um],ZML1 [POSITION][um],rML1 [POSITION][deg],pML1 [POSITION][deg],yML1 [POSITION][deg],XBLD [POSITION][um],YBLD [POSITION][um],rBLD [POSITION][deg],XAPT [POSITION][um],YAPT [POSITION][um]'
                    cols      = header.split(',')
                    # so there is either 'str [att][unit]' or str [att]
                    for t in cols :
                        if t.count('[') == 1 :
                            var  = t.split(' ')[0].strip()
                            att  = t[ t.find('[')+1 : t.find(']')].strip()
                            col_names.append(var)
                            att_names.append(att)
                            if not motor_pos.has_key(var) :
                                motor_pos[var] = {}
                                motor_pos[var][att] = {}
                                motor_pos[var][att]['value'] = []
                                motor_pos[var][att]['unit'] = 1
                                
                                if verbose :
                                    print 'header column:', t
                                    print 'Variable     :', var
                                    print 'Attribute    :', att
                                    print '\n'
                            
                        elif t.count('[') == 2 :
                            var  = t.split(' ')[0].strip()
                            att  = t[ t.find('[')+1 : t.find(']')].strip()
                            unit = str_to_unit(t[ t.rfind('[')+1 : t.rfind(']')])
                            # if unit is None that means Martin did not know what the unit
                            # was, in this case we should assume that the unit is the same
                            # as it was in the last header statement
                            col_names.append(var)
                            att_names.append(att)
                            if not motor_pos.has_key(var) :
                                motor_pos[var] = {}
                                motor_pos[var][att] = {}
                                motor_pos[var][att]['value'] = []
                                motor_pos[var][att]['unit'] = unit
                                
                                if verbose :
                                    print 'header column:', t
                                    print 'Variable     :', var
                                    print 'Attribute    :', att
                                    print 'Unit         :', unit
                                    print '\n'
                        else :
                            print 'Cannot parse header column:', t
                    
                    if verbose :
                        print 'motor_pos:'
                        for key in motor_pos.keys():
                            print key, motor_pos[key]
                                
                        print '\ncol_names:'
                        for c in col_names :
                            print c

    status = "Done...\r\n"
    sys.stdout.write(text + ' ' + status)
    sys.stdout.flush()

    print '\nConverting to numpy arrays:'
    for key in motor_pos.keys():
        for att in motor_pos[key].keys():
            print key, att, len(motor_pos[key][att]['value'])
            motor_pos[key][att]['value'] = np.array(motor_pos[key][att]['value'])

    fnam = 'motorPositions_fixed.pickle'
    print '\nDumping contents to', fnam
    import cPickle
    cPickle.dump(motor_pos, open(fnam, 'wb'))
    
    return motor_pos 

def find_nearest_motor_pos(motor_pos, name, UnixTime):
    """
    Find the logged motor position closest to 'UnixTime'
    """
    i   = np.searchsorted(motor_pos['Timestamp']['UnixTime']['value'], UnixTime)

    att = motor_pos[name].keys()[0]
    return motor_pos[name][att]['value'][i]

def print_key_value(key, value, tabs=0):
    if type(value) is dict :
        print tabs * '\t', key, ':'
        for key2, value2 in value.iteritems():
            print_key_value(key2, value2, tabs = tabs + 1)
    else :
        try :
            if len(value) > 10 and type(value) is not str :
                print tabs * '\t', key, ':\n'
                print (tabs+1) * '\t', value[:4]
                print (tabs+1) * '\t', '...'
                print (tabs+1) * '\t', value[-4:]
            else :
                print tabs * '\t', key, ':', value
        except :
            print tabs * '\t', key, ':', value

def print_log(log, name, tabs = 0):
    print '\n'
    print name
    print '----------'
    print '\n'
    
    for key, value in log.iteritems():
        print_key_value(key, value, tabs = tabs)



if __name__ == '__main__':
    fnam = sys.argv[1]
    l = Log_file_v02(fnam)
    # l.log is the logfile dict
    print_log(l.log, l.fnam)
